# ****************************************************************************************************
# Generated 2020-07-06

import numpy as np
from wrapanime.root.root import ArrayOf, Wrapper, to_array

# ************************************************************************************
# Class WEdge automatically generated by wa_sourcegen

class WEdge(Wrapper):

    # ================================================================================
    # Direct properties wrappers

    @property
    def bevel_weight(self) -> float:
        return self.obj.bevel_weight

    @bevel_weight.setter
    def bevel_weight(self, value): # float
        self.obj.bevel_weight = value

    @property
    def crease(self) -> float:
        return self.obj.crease

    @crease.setter
    def crease(self, value): # float
        self.obj.crease = value

    @property
    def hide(self) -> bool:
        return self.obj.hide

    @hide.setter
    def hide(self, value): # bool
        self.obj.hide = value

    @property
    def index(self) -> int:
        return self.obj.index

    @index.setter
    def index(self, value): # int
        self.obj.index = value

    @property
    def is_loose(self) -> bool:
        return self.obj.is_loose

    @is_loose.setter
    def is_loose(self, value): # bool
        self.obj.is_loose = value

    @property
    def select(self) -> bool:
        return self.obj.select

    @select.setter
    def select(self, value): # bool
        self.obj.select = value

    @property
    def use_edge_sharp(self) -> bool:
        return self.obj.use_edge_sharp

    @use_edge_sharp.setter
    def use_edge_sharp(self, value): # bool
        self.obj.use_edge_sharp = value

    @property
    def use_seam(self) -> bool:
        return self.obj.use_seam

    @use_seam.setter
    def use_seam(self, value): # bool
        self.obj.use_seam = value

    @property
    def vertices(self): # array
        return self.obj.vertices

    @vertices.setter
    def vertices(self, value): # array
        self.obj.vertices = value



# ************************************************************************************
# Class ArrayOf WEdge automatically generated by wa_sourcegen

class ArrayOfWEdge(ArrayOf):

    # ================================================================================
    # Initialization
    # Create the cache properties

    def __init__(self, wowner):
        super().__init__(WEdge, wowner)

        self._cache_bevel_weights                = None
        self._cache_creases                      = None
        self._cache_hides                        = None
        self._cache_indices                      = None
        self._cache_is_looses                    = None
        self._cache_selects                      = None
        self._cache_use_edge_sharps              = None
        self._cache_use_seams                    = None

    # ================================================================================
    # Erase cache
    def erase_cache(self):
        super().erase_cache()

        self._cache_bevel_weights                = None
        self._cache_creases                      = None
        self._cache_hides                        = None
        self._cache_indices                      = None
        self._cache_is_looses                    = None
        self._cache_selects                      = None
        self._cache_use_edge_sharps              = None
        self._cache_use_seams                    = None

    # ================================================================================
    # Vectorized access to properties in collection of wrapped classes

    @property
    def bevel_weights(self): # array of float
        values = self._cache_bevel_weights
        if values is None:
            values = np.empty(len(self), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.bevel_weight
            self._cache_bevel_weights = values
        return values

    @bevel_weights.setter
    def bevel_weights(self, values): # array of float
        self._cache_bevel_weights = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_bevel_weights):
            obj.bevel_weight = v

    @property
    def creases(self): # array of float
        values = self._cache_creases
        if values is None:
            values = np.empty(len(self), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.crease
            self._cache_creases = values
        return values

    @creases.setter
    def creases(self, values): # array of float
        self._cache_creases = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_creases):
            obj.crease = v

    @property
    def hides(self): # array of bool
        values = self._cache_hides
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.hide
            self._cache_hides = values
        return values

    @hides.setter
    def hides(self, values): # array of bool
        self._cache_hides = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_hides):
            obj.hide = v

    @property
    def indices(self): # array of int
        values = self._cache_indices
        if values is None:
            values = np.empty(len(self), np.int)
            for i, obj in enumerate(self._array):
                values[i] = obj.index
            self._cache_indices = values
        return values

    @indices.setter
    def indices(self, values): # array of int
        self._cache_indices = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_indices):
            obj.index = v

    @property
    def is_looses(self): # array of bool
        values = self._cache_is_looses
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.is_loose
            self._cache_is_looses = values
        return values

    @is_looses.setter
    def is_looses(self, values): # array of bool
        self._cache_is_looses = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_is_looses):
            obj.is_loose = v

    @property
    def selects(self): # array of bool
        values = self._cache_selects
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.select
            self._cache_selects = values
        return values

    @selects.setter
    def selects(self, values): # array of bool
        self._cache_selects = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_selects):
            obj.select = v

    @property
    def use_edge_sharps(self): # array of bool
        values = self._cache_use_edge_sharps
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.use_edge_sharp
            self._cache_use_edge_sharps = values
        return values

    @use_edge_sharps.setter
    def use_edge_sharps(self, values): # array of bool
        self._cache_use_edge_sharps = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_use_edge_sharps):
            obj.use_edge_sharp = v

    @property
    def use_seams(self): # array of bool
        values = self._cache_use_seams
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.use_seam
            self._cache_use_seams = values
        return values

    @use_seams.setter
    def use_seams(self, values): # array of bool
        self._cache_use_seams = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_use_seams):
            obj.use_seam = v


# ************************************************************************************
# Class WLoop automatically generated by wa_sourcegen

class WLoop(Wrapper):

    # ================================================================================
    # Direct properties wrappers

    @property
    def bitangent_sign(self) -> float:
        return self.obj.bitangent_sign

    @bitangent_sign.setter
    def bitangent_sign(self, value): # float
        self.obj.bitangent_sign = value

    @property
    def bitangent(self): # V3
        return self.obj.bitangent

    @bitangent.setter
    def bitangent(self, value): # V3
        self.obj.bitangent = value

    @property
    def edge_index(self) -> int:
        return self.obj.edge_index

    @edge_index.setter
    def edge_index(self, value): # int
        self.obj.edge_index = value

    @property
    def index(self) -> int:
        return self.obj.index

    @index.setter
    def index(self, value): # int
        self.obj.index = value

    @property
    def normal(self): # V3
        return self.obj.normal

    @normal.setter
    def normal(self, value): # V3
        self.obj.normal = value

    @property
    def tangent(self): # V3
        return self.obj.tangent

    @tangent.setter
    def tangent(self, value): # V3
        self.obj.tangent = value

    @property
    def vertex_index(self) -> int:
        return self.obj.vertex_index

    @vertex_index.setter
    def vertex_index(self, value): # int
        self.obj.vertex_index = value



# ************************************************************************************
# Class ArrayOf WLoop automatically generated by wa_sourcegen

class ArrayOfWLoop(ArrayOf):

    # ================================================================================
    # Initialization
    # Create the cache properties

    def __init__(self, wowner):
        super().__init__(WLoop, wowner)

        self._cache_bitangent_signs              = None
        self._cache_bitangents                   = None
        self._cache_edge_indices                 = None
        self._cache_indices                      = None
        self._cache_normals                      = None
        self._cache_tangents                     = None
        self._cache_vertex_indices               = None

    # ================================================================================
    # Erase cache
    def erase_cache(self):
        super().erase_cache()

        self._cache_bitangent_signs              = None
        self._cache_bitangents                   = None
        self._cache_edge_indices                 = None
        self._cache_indices                      = None
        self._cache_normals                      = None
        self._cache_tangents                     = None
        self._cache_vertex_indices               = None

    # ================================================================================
    # Vectorized access to properties in collection of wrapped classes

    @property
    def bitangent_signs(self): # array of float
        values = self._cache_bitangent_signs
        if values is None:
            values = np.empty(len(self), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.bitangent_sign
            self._cache_bitangent_signs = values
        return values

    @bitangent_signs.setter
    def bitangent_signs(self, values): # array of float
        self._cache_bitangent_signs = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_bitangent_signs):
            obj.bitangent_sign = v

    @property
    def bitangents(self): # array of V3
        values = self._cache_bitangents
        if values is None:
            values = np.empty((len(self), 3), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.bitangent
            self._cache_bitangents = values
        return values

    @bitangents.setter
    def bitangents(self, values): # array of V3
        self._cache_bitangents = np.array(to_array(values, (len(self), 3), '3-vector or array of 3-vectors'))
        for obj, v in zip(self._array, self._cache_bitangents):
            obj.bitangent = v

    @property
    def edge_indices(self): # array of int
        values = self._cache_edge_indices
        if values is None:
            values = np.empty(len(self), np.int)
            for i, obj in enumerate(self._array):
                values[i] = obj.edge_index
            self._cache_edge_indices = values
        return values

    @edge_indices.setter
    def edge_indices(self, values): # array of int
        self._cache_edge_indices = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_edge_indices):
            obj.edge_index = v

    @property
    def indices(self): # array of int
        values = self._cache_indices
        if values is None:
            values = np.empty(len(self), np.int)
            for i, obj in enumerate(self._array):
                values[i] = obj.index
            self._cache_indices = values
        return values

    @indices.setter
    def indices(self, values): # array of int
        self._cache_indices = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_indices):
            obj.index = v

    @property
    def normals(self): # array of V3
        values = self._cache_normals
        if values is None:
            values = np.empty((len(self), 3), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.normal
            self._cache_normals = values
        return values

    @normals.setter
    def normals(self, values): # array of V3
        self._cache_normals = np.array(to_array(values, (len(self), 3), '3-vector or array of 3-vectors'))
        for obj, v in zip(self._array, self._cache_normals):
            obj.normal = v

    @property
    def tangents(self): # array of V3
        values = self._cache_tangents
        if values is None:
            values = np.empty((len(self), 3), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.tangent
            self._cache_tangents = values
        return values

    @tangents.setter
    def tangents(self, values): # array of V3
        self._cache_tangents = np.array(to_array(values, (len(self), 3), '3-vector or array of 3-vectors'))
        for obj, v in zip(self._array, self._cache_tangents):
            obj.tangent = v

    @property
    def vertex_indices(self): # array of int
        values = self._cache_vertex_indices
        if values is None:
            values = np.empty(len(self), np.int)
            for i, obj in enumerate(self._array):
                values[i] = obj.vertex_index
            self._cache_vertex_indices = values
        return values

    @vertex_indices.setter
    def vertex_indices(self, values): # array of int
        self._cache_vertex_indices = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_vertex_indices):
            obj.vertex_index = v


# ************************************************************************************
# Class WPolygon automatically generated by wa_sourcegen

class WPolygon(Wrapper):

    # ================================================================================
    # Direct properties wrappers

    @property
    def area(self) -> float:
        return self.obj.area

    @area.setter
    def area(self, value): # float
        self.obj.area = value

    @property
    def center(self): # V3
        return self.obj.center

    @center.setter
    def center(self, value): # V3
        self.obj.center = value

    @property
    def hide(self) -> bool:
        return self.obj.hide

    @hide.setter
    def hide(self, value): # bool
        self.obj.hide = value

    @property
    def index(self) -> int:
        return self.obj.index

    @index.setter
    def index(self, value): # int
        self.obj.index = value

    @property
    def loop_start(self) -> int:
        return self.obj.loop_start

    @loop_start.setter
    def loop_start(self, value): # int
        self.obj.loop_start = value

    @property
    def loop_total(self) -> int:
        return self.obj.loop_total

    @loop_total.setter
    def loop_total(self, value): # int
        self.obj.loop_total = value

    @property
    def material_index(self) -> int:
        return self.obj.material_index

    @material_index.setter
    def material_index(self, value): # int
        self.obj.material_index = value

    @property
    def normal(self): # V3
        return self.obj.normal

    @normal.setter
    def normal(self, value): # V3
        self.obj.normal = value

    @property
    def use_smooth(self) -> bool:
        return self.obj.use_smooth

    @use_smooth.setter
    def use_smooth(self, value): # bool
        self.obj.use_smooth = value

    @property
    def vertices(self): # array
        return self.obj.vertices

    @vertices.setter
    def vertices(self, value): # array
        self.obj.vertices = value



# ************************************************************************************
# Class ArrayOf WPolygon automatically generated by wa_sourcegen

class ArrayOfWPolygon(ArrayOf):

    # ================================================================================
    # Initialization
    # Create the cache properties

    def __init__(self, wowner):
        super().__init__(WPolygon, wowner)

        self._cache_areas                        = None
        self._cache_centers                      = None
        self._cache_hides                        = None
        self._cache_indices                      = None
        self._cache_loop_starts                  = None
        self._cache_loop_totals                  = None
        self._cache_material_indices             = None
        self._cache_normals                      = None
        self._cache_use_smooths                  = None

    # ================================================================================
    # Erase cache
    def erase_cache(self):
        super().erase_cache()

        self._cache_areas                        = None
        self._cache_centers                      = None
        self._cache_hides                        = None
        self._cache_indices                      = None
        self._cache_loop_starts                  = None
        self._cache_loop_totals                  = None
        self._cache_material_indices             = None
        self._cache_normals                      = None
        self._cache_use_smooths                  = None

    # ================================================================================
    # Vectorized access to properties in collection of wrapped classes

    @property
    def areas(self): # array of float
        values = self._cache_areas
        if values is None:
            values = np.empty(len(self), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.area
            self._cache_areas = values
        return values

    @areas.setter
    def areas(self, values): # array of float
        self._cache_areas = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_areas):
            obj.area = v

    @property
    def centers(self): # array of V3
        values = self._cache_centers
        if values is None:
            values = np.empty((len(self), 3), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.center
            self._cache_centers = values
        return values

    @centers.setter
    def centers(self, values): # array of V3
        self._cache_centers = np.array(to_array(values, (len(self), 3), '3-vector or array of 3-vectors'))
        for obj, v in zip(self._array, self._cache_centers):
            obj.center = v

    @property
    def hides(self): # array of bool
        values = self._cache_hides
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.hide
            self._cache_hides = values
        return values

    @hides.setter
    def hides(self, values): # array of bool
        self._cache_hides = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_hides):
            obj.hide = v

    @property
    def indices(self): # array of int
        values = self._cache_indices
        if values is None:
            values = np.empty(len(self), np.int)
            for i, obj in enumerate(self._array):
                values[i] = obj.index
            self._cache_indices = values
        return values

    @indices.setter
    def indices(self, values): # array of int
        self._cache_indices = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_indices):
            obj.index = v

    @property
    def loop_starts(self): # array of int
        values = self._cache_loop_starts
        if values is None:
            values = np.empty(len(self), np.int)
            for i, obj in enumerate(self._array):
                values[i] = obj.loop_start
            self._cache_loop_starts = values
        return values

    @loop_starts.setter
    def loop_starts(self, values): # array of int
        self._cache_loop_starts = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_loop_starts):
            obj.loop_start = v

    @property
    def loop_totals(self): # array of int
        values = self._cache_loop_totals
        if values is None:
            values = np.empty(len(self), np.int)
            for i, obj in enumerate(self._array):
                values[i] = obj.loop_total
            self._cache_loop_totals = values
        return values

    @loop_totals.setter
    def loop_totals(self, values): # array of int
        self._cache_loop_totals = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_loop_totals):
            obj.loop_total = v

    @property
    def material_indices(self): # array of int
        values = self._cache_material_indices
        if values is None:
            values = np.empty(len(self), np.int)
            for i, obj in enumerate(self._array):
                values[i] = obj.material_index
            self._cache_material_indices = values
        return values

    @material_indices.setter
    def material_indices(self, values): # array of int
        self._cache_material_indices = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_material_indices):
            obj.material_index = v

    @property
    def normals(self): # array of V3
        values = self._cache_normals
        if values is None:
            values = np.empty((len(self), 3), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.normal
            self._cache_normals = values
        return values

    @normals.setter
    def normals(self, values): # array of V3
        self._cache_normals = np.array(to_array(values, (len(self), 3), '3-vector or array of 3-vectors'))
        for obj, v in zip(self._array, self._cache_normals):
            obj.normal = v

    @property
    def use_smooths(self): # array of bool
        values = self._cache_use_smooths
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.use_smooth
            self._cache_use_smooths = values
        return values

    @use_smooths.setter
    def use_smooths(self, values): # array of bool
        self._cache_use_smooths = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_use_smooths):
            obj.use_smooth = v


# ************************************************************************************
# Class WMeshVertex automatically generated by wa_sourcegen

class WMeshVertex(Wrapper):

    # ================================================================================
    # Direct properties wrappers

    @property
    def bevel_weight(self) -> float:
        return self.obj.bevel_weight

    @bevel_weight.setter
    def bevel_weight(self, value): # float
        self.obj.bevel_weight = value

    @property
    def co(self): # V3
        return self.obj.co

    @co.setter
    def co(self, value): # V3
        self.obj.co = value

    @property
    def hide(self) -> bool:
        return self.obj.hide

    @hide.setter
    def hide(self, value): # bool
        self.obj.hide = value

    @property
    def index(self) -> int:
        return self.obj.index

    @index.setter
    def index(self, value): # int
        self.obj.index = value

    @property
    def normal(self): # V3
        return self.obj.normal

    @normal.setter
    def normal(self, value): # V3
        self.obj.normal = value

    @property
    def undeformed_co(self): # V3
        return self.obj.undeformed_co

    @undeformed_co.setter
    def undeformed_co(self, value): # V3
        self.obj.undeformed_co = value



# ************************************************************************************
# Class ArrayOf WMeshVertex automatically generated by wa_sourcegen

class ArrayOfWMeshVertex(ArrayOf):

    # ================================================================================
    # Initialization
    # Create the cache properties

    def __init__(self, wowner):
        super().__init__(WMeshVertex, wowner)

        self._cache_bevel_weights                = None
        self._cache_cos                          = None
        self._cache_hides                        = None
        self._cache_indices                      = None
        self._cache_normals                      = None
        self._cache_undeformed_cos               = None

    # ================================================================================
    # Erase cache
    def erase_cache(self):
        super().erase_cache()

        self._cache_bevel_weights                = None
        self._cache_cos                          = None
        self._cache_hides                        = None
        self._cache_indices                      = None
        self._cache_normals                      = None
        self._cache_undeformed_cos               = None

    # ================================================================================
    # Vectorized access to properties in collection of wrapped classes

    @property
    def bevel_weights(self): # array of float
        values = self._cache_bevel_weights
        if values is None:
            values = np.empty(len(self), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.bevel_weight
            self._cache_bevel_weights = values
        return values

    @bevel_weights.setter
    def bevel_weights(self, values): # array of float
        self._cache_bevel_weights = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_bevel_weights):
            obj.bevel_weight = v

    @property
    def cos(self): # array of V3
        values = self._cache_cos
        if values is None:
            values = np.empty((len(self), 3), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.co
            self._cache_cos = values
        return values

    @cos.setter
    def cos(self, values): # array of V3
        self._cache_cos = np.array(to_array(values, (len(self), 3), '3-vector or array of 3-vectors'))
        for obj, v in zip(self._array, self._cache_cos):
            obj.co = v

    @property
    def hides(self): # array of bool
        values = self._cache_hides
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.hide
            self._cache_hides = values
        return values

    @hides.setter
    def hides(self, values): # array of bool
        self._cache_hides = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_hides):
            obj.hide = v

    @property
    def indices(self): # array of int
        values = self._cache_indices
        if values is None:
            values = np.empty(len(self), np.int)
            for i, obj in enumerate(self._array):
                values[i] = obj.index
            self._cache_indices = values
        return values

    @indices.setter
    def indices(self, values): # array of int
        self._cache_indices = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_indices):
            obj.index = v

    @property
    def normals(self): # array of V3
        values = self._cache_normals
        if values is None:
            values = np.empty((len(self), 3), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.normal
            self._cache_normals = values
        return values

    @normals.setter
    def normals(self, values): # array of V3
        self._cache_normals = np.array(to_array(values, (len(self), 3), '3-vector or array of 3-vectors'))
        for obj, v in zip(self._array, self._cache_normals):
            obj.normal = v

    @property
    def undeformed_cos(self): # array of V3
        values = self._cache_undeformed_cos
        if values is None:
            values = np.empty((len(self), 3), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.undeformed_co
            self._cache_undeformed_cos = values
        return values

    @undeformed_cos.setter
    def undeformed_cos(self, values): # array of V3
        self._cache_undeformed_cos = np.array(to_array(values, (len(self), 3), '3-vector or array of 3-vectors'))
        for obj, v in zip(self._array, self._cache_undeformed_cos):
            obj.undeformed_co = v


# ************************************************************************************
# Class WMesh automatically generated by wa_sourcegen

class WMesh(Wrapper):

    # ================================================================================
    # Initialization
    # Create cache properties

    def __init__(self, obj, wowner):
        super().__init__(obj, wowner)

        self._cache_wedges        = None
        self._cache_wloops        = None
        self._cache_wpolygons     = None
        self._cache_wvertices     = None

    # ================================================================================
    # Wrap a collection of wrapped objects

    def erase_cache(self):
        super().erase_cache()

        if self._cache_wedges is not None:
            self._cache_wedges.erase_cache()
            self._cache_wedges = None

        if self._cache_wloops is not None:
            self._cache_wloops.erase_cache()
            self._cache_wloops = None

        if self._cache_wpolygons is not None:
            self._cache_wpolygons.erase_cache()
            self._cache_wpolygons = None

        if self._cache_wvertices is not None:
            self._cache_wvertices.erase_cache()
            self._cache_wvertices = None

    @property
    def wedges(self): # Array of WEdge
        arrayof = self._cache_wedges
        if arrayof is None:
            arrayof = ArrayOfWEdge(self)
            arrayof.array = self.obj.edges
        self._cache_wedges = arrayof
        return arrayof

    @property
    def wloops(self): # Array of WLoop
        arrayof = self._cache_wloops
        if arrayof is None:
            arrayof = ArrayOfWLoop(self)
            arrayof.array = self.obj.loops
        self._cache_wloops = arrayof
        return arrayof

    @property
    def wpolygons(self): # Array of WPolygon
        arrayof = self._cache_wpolygons
        if arrayof is None:
            arrayof = ArrayOfWPolygon(self)
            arrayof.array = self.obj.polygons
        self._cache_wpolygons = arrayof
        return arrayof

    @property
    def wvertices(self): # Array of WMeshVertex
        arrayof = self._cache_wvertices
        if arrayof is None:
            arrayof = ArrayOfWMeshVertex(self)
            arrayof.array = self.obj.vertices
        self._cache_wvertices = arrayof
        return arrayof


    # ================================================================================
    # Direct properties wrappers

    @property
    def auto_smooth_angle(self) -> float:
        return self.obj.auto_smooth_angle

    @auto_smooth_angle.setter
    def auto_smooth_angle(self, value): # float
        self.obj.auto_smooth_angle = value

    @property
    def auto_texspace(self) -> bool:
        return self.obj.auto_texspace

    @auto_texspace.setter
    def auto_texspace(self, value): # bool
        self.obj.auto_texspace = value

    @property
    def edges(self): # AWEdge
        return self.obj.edges

    @edges.setter
    def edges(self, value): # AWEdge
        self.obj.edges = value

    @property
    def loops(self): # AWLoop
        return self.obj.loops

    @loops.setter
    def loops(self, value): # AWLoop
        self.obj.loops = value

    @property
    def polygons(self): # AWPolygon
        return self.obj.polygons

    @polygons.setter
    def polygons(self, value): # AWPolygon
        self.obj.polygons = value

    @property
    def use_auto_smooth(self) -> bool:
        return self.obj.use_auto_smooth

    @use_auto_smooth.setter
    def use_auto_smooth(self, value): # bool
        self.obj.use_auto_smooth = value

    @property
    def use_auto_texspace(self) -> bool:
        return self.obj.use_auto_texspace

    @use_auto_texspace.setter
    def use_auto_texspace(self, value): # bool
        self.obj.use_auto_texspace = value

    @property
    def vertices(self): # AWMeshVertex
        return self.obj.vertices

    @vertices.setter
    def vertices(self, value): # AWMeshVertex
        self.obj.vertices = value



# ************************************************************************************
# Class ArrayOf WMesh automatically generated by wa_sourcegen

class ArrayOfWMesh(ArrayOf):

    # ================================================================================
    # Initialization
    # Create the cache properties

    def __init__(self, wowner):
        super().__init__(WMesh, wowner)

        self._cache_auto_smooth_angles           = None
        self._cache_auto_texspaces               = None
        self._cache_use_auto_smooths             = None
        self._cache_use_auto_texspaces           = None

    # ================================================================================
    # Erase cache
    def erase_cache(self):
        super().erase_cache()

        self._cache_auto_smooth_angles           = None
        self._cache_auto_texspaces               = None
        self._cache_use_auto_smooths             = None
        self._cache_use_auto_texspaces           = None

    # ================================================================================
    # Vectorized access to properties in collection of wrapped classes

    @property
    def auto_smooth_angles(self): # array of float
        values = self._cache_auto_smooth_angles
        if values is None:
            values = np.empty(len(self), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.auto_smooth_angle
            self._cache_auto_smooth_angles = values
        return values

    @auto_smooth_angles.setter
    def auto_smooth_angles(self, values): # array of float
        self._cache_auto_smooth_angles = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_auto_smooth_angles):
            obj.auto_smooth_angle = v

    @property
    def auto_texspaces(self): # array of bool
        values = self._cache_auto_texspaces
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.auto_texspace
            self._cache_auto_texspaces = values
        return values

    @auto_texspaces.setter
    def auto_texspaces(self, values): # array of bool
        self._cache_auto_texspaces = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_auto_texspaces):
            obj.auto_texspace = v

    @property
    def use_auto_smooths(self): # array of bool
        values = self._cache_use_auto_smooths
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.use_auto_smooth
            self._cache_use_auto_smooths = values
        return values

    @use_auto_smooths.setter
    def use_auto_smooths(self, values): # array of bool
        self._cache_use_auto_smooths = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_use_auto_smooths):
            obj.use_auto_smooth = v

    @property
    def use_auto_texspaces(self): # array of bool
        values = self._cache_use_auto_texspaces
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.use_auto_texspace
            self._cache_use_auto_texspaces = values
        return values

    @use_auto_texspaces.setter
    def use_auto_texspaces(self, values): # array of bool
        self._cache_use_auto_texspaces = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_use_auto_texspaces):
            obj.use_auto_texspace = v


# ************************************************************************************
# Class WBezierSplinePoint automatically generated by wa_sourcegen

class WBezierSplinePoint(Wrapper):

    # ================================================================================
    # Direct properties wrappers

    @property
    def co(self): # V3
        return self.obj.co

    @co.setter
    def co(self, value): # V3
        self.obj.co = value

    @property
    def handle_left_type(self) -> str:
        return self.obj.handle_left_type

    @handle_left_type.setter
    def handle_left_type(self, value): # str
        self.obj.handle_left_type = value

    @property
    def handle_left(self): # V3
        return self.obj.handle_left

    @handle_left.setter
    def handle_left(self, value): # V3
        self.obj.handle_left = value

    @property
    def handle_right_type(self) -> str:
        return self.obj.handle_right_type

    @handle_right_type.setter
    def handle_right_type(self, value): # str
        self.obj.handle_right_type = value

    @property
    def handle_right(self): # V3
        return self.obj.handle_right

    @handle_right.setter
    def handle_right(self, value): # V3
        self.obj.handle_right = value

    @property
    def hide(self) -> bool:
        return self.obj.hide

    @hide.setter
    def hide(self, value): # bool
        self.obj.hide = value

    @property
    def radius(self) -> float:
        return self.obj.radius

    @radius.setter
    def radius(self, value): # float
        self.obj.radius = value

    @property
    def tilt(self) -> int:
        return self.obj.tilt

    @tilt.setter
    def tilt(self, value): # int
        self.obj.tilt = value

    @property
    def weight_softbody(self) -> float:
        return self.obj.weight_softbody

    @weight_softbody.setter
    def weight_softbody(self, value): # float
        self.obj.weight_softbody = value



# ************************************************************************************
# Class ArrayOf WBezierSplinePoint automatically generated by wa_sourcegen

class ArrayOfWBezierSplinePoint(ArrayOf):

    # ================================================================================
    # Initialization
    # Create the cache properties

    def __init__(self, wowner):
        super().__init__(WBezierSplinePoint, wowner)

        self._cache_cos                          = None
        self._cache_handle_left_types            = None
        self._cache_handle_lefts                 = None
        self._cache_handle_right_types           = None
        self._cache_handle_rights                = None
        self._cache_hides                        = None
        self._cache_radius_s                     = None
        self._cache_tilts                        = None
        self._cache_weight_softbodys             = None

    # ================================================================================
    # Erase cache
    def erase_cache(self):
        super().erase_cache()

        self._cache_cos                          = None
        self._cache_handle_left_types            = None
        self._cache_handle_lefts                 = None
        self._cache_handle_right_types           = None
        self._cache_handle_rights                = None
        self._cache_hides                        = None
        self._cache_radius_s                     = None
        self._cache_tilts                        = None
        self._cache_weight_softbodys             = None

    # ================================================================================
    # Vectorized access to properties in collection of wrapped classes

    @property
    def cos(self): # array of V3
        values = self._cache_cos
        if values is None:
            values = np.empty((len(self), 3), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.co
            self._cache_cos = values
        return values

    @cos.setter
    def cos(self, values): # array of V3
        self._cache_cos = np.array(to_array(values, (len(self), 3), '3-vector or array of 3-vectors'))
        for obj, v in zip(self._array, self._cache_cos):
            obj.co = v

    @property
    def handle_left_types(self): # array of str
        values = self._cache_handle_left_types
        if values is None:
            values = np.empty(len(self), np.object)
            for i, obj in enumerate(self._array):
                values[i] = obj.handle_left_type
            self._cache_handle_left_types = values
        return values

    @handle_left_types.setter
    def handle_left_types(self, values): # array of str
        self._cache_handle_left_types = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_handle_left_types):
            obj.handle_left_type = v

    @property
    def handle_lefts(self): # array of V3
        values = self._cache_handle_lefts
        if values is None:
            values = np.empty((len(self), 3), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.handle_left
            self._cache_handle_lefts = values
        return values

    @handle_lefts.setter
    def handle_lefts(self, values): # array of V3
        self._cache_handle_lefts = np.array(to_array(values, (len(self), 3), '3-vector or array of 3-vectors'))
        for obj, v in zip(self._array, self._cache_handle_lefts):
            obj.handle_left = v

    @property
    def handle_right_types(self): # array of str
        values = self._cache_handle_right_types
        if values is None:
            values = np.empty(len(self), np.object)
            for i, obj in enumerate(self._array):
                values[i] = obj.handle_right_type
            self._cache_handle_right_types = values
        return values

    @handle_right_types.setter
    def handle_right_types(self, values): # array of str
        self._cache_handle_right_types = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_handle_right_types):
            obj.handle_right_type = v

    @property
    def handle_rights(self): # array of V3
        values = self._cache_handle_rights
        if values is None:
            values = np.empty((len(self), 3), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.handle_right
            self._cache_handle_rights = values
        return values

    @handle_rights.setter
    def handle_rights(self, values): # array of V3
        self._cache_handle_rights = np.array(to_array(values, (len(self), 3), '3-vector or array of 3-vectors'))
        for obj, v in zip(self._array, self._cache_handle_rights):
            obj.handle_right = v

    @property
    def hides(self): # array of bool
        values = self._cache_hides
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.hide
            self._cache_hides = values
        return values

    @hides.setter
    def hides(self, values): # array of bool
        self._cache_hides = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_hides):
            obj.hide = v

    @property
    def radius_s(self): # array of float
        values = self._cache_radius_s
        if values is None:
            values = np.empty(len(self), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.radius
            self._cache_radius_s = values
        return values

    @radius_s.setter
    def radius_s(self, values): # array of float
        self._cache_radius_s = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_radius_s):
            obj.radius = v

    @property
    def tilts(self): # array of int
        values = self._cache_tilts
        if values is None:
            values = np.empty(len(self), np.int)
            for i, obj in enumerate(self._array):
                values[i] = obj.tilt
            self._cache_tilts = values
        return values

    @tilts.setter
    def tilts(self, values): # array of int
        self._cache_tilts = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_tilts):
            obj.tilt = v

    @property
    def weight_softbodys(self): # array of float
        values = self._cache_weight_softbodys
        if values is None:
            values = np.empty(len(self), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.weight_softbody
            self._cache_weight_softbodys = values
        return values

    @weight_softbodys.setter
    def weight_softbodys(self, values): # array of float
        self._cache_weight_softbodys = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_weight_softbodys):
            obj.weight_softbody = v


# ************************************************************************************
# Class WSplinePoint automatically generated by wa_sourcegen

class WSplinePoint(Wrapper):

    # ================================================================================
    # Direct properties wrappers

    @property
    def co(self): # V3
        return self.obj.co

    @co.setter
    def co(self, value): # V3
        self.obj.co = value

    @property
    def radius(self) -> float:
        return self.obj.radius

    @radius.setter
    def radius(self, value): # float
        self.obj.radius = value

    @property
    def tilt(self) -> float:
        return self.obj.tilt

    @tilt.setter
    def tilt(self, value): # float
        self.obj.tilt = value

    @property
    def weight_softbody(self) -> float:
        return self.obj.weight_softbody

    @weight_softbody.setter
    def weight_softbody(self, value): # float
        self.obj.weight_softbody = value

    @property
    def weight(self) -> float:
        return self.obj.weight

    @weight.setter
    def weight(self, value): # float
        self.obj.weight = value



# ************************************************************************************
# Class ArrayOf WSplinePoint automatically generated by wa_sourcegen

class ArrayOfWSplinePoint(ArrayOf):

    # ================================================================================
    # Initialization
    # Create the cache properties

    def __init__(self, wowner):
        super().__init__(WSplinePoint, wowner)

        self._cache_cos                          = None
        self._cache_radius_s                     = None
        self._cache_tilts                        = None
        self._cache_weight_softbodys             = None
        self._cache_weights                      = None

    # ================================================================================
    # Erase cache
    def erase_cache(self):
        super().erase_cache()

        self._cache_cos                          = None
        self._cache_radius_s                     = None
        self._cache_tilts                        = None
        self._cache_weight_softbodys             = None
        self._cache_weights                      = None

    # ================================================================================
    # Vectorized access to properties in collection of wrapped classes

    @property
    def cos(self): # array of V3
        values = self._cache_cos
        if values is None:
            values = np.empty((len(self), 3), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.co
            self._cache_cos = values
        return values

    @cos.setter
    def cos(self, values): # array of V3
        self._cache_cos = np.array(to_array(values, (len(self), 3), '3-vector or array of 3-vectors'))
        for obj, v in zip(self._array, self._cache_cos):
            obj.co = v

    @property
    def radius_s(self): # array of float
        values = self._cache_radius_s
        if values is None:
            values = np.empty(len(self), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.radius
            self._cache_radius_s = values
        return values

    @radius_s.setter
    def radius_s(self, values): # array of float
        self._cache_radius_s = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_radius_s):
            obj.radius = v

    @property
    def tilts(self): # array of float
        values = self._cache_tilts
        if values is None:
            values = np.empty(len(self), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.tilt
            self._cache_tilts = values
        return values

    @tilts.setter
    def tilts(self, values): # array of float
        self._cache_tilts = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_tilts):
            obj.tilt = v

    @property
    def weight_softbodys(self): # array of float
        values = self._cache_weight_softbodys
        if values is None:
            values = np.empty(len(self), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.weight_softbody
            self._cache_weight_softbodys = values
        return values

    @weight_softbodys.setter
    def weight_softbodys(self, values): # array of float
        self._cache_weight_softbodys = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_weight_softbodys):
            obj.weight_softbody = v

    @property
    def weights(self): # array of float
        values = self._cache_weights
        if values is None:
            values = np.empty(len(self), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.weight
            self._cache_weights = values
        return values

    @weights.setter
    def weights(self, values): # array of float
        self._cache_weights = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_weights):
            obj.weight = v


# ************************************************************************************
# Class WSpline automatically generated by wa_sourcegen

class WSpline(Wrapper):

    # ================================================================================
    # Initialization
    # Create cache properties

    def __init__(self, obj, wowner):
        super().__init__(obj, wowner)

        self._cache_wbezier_points = None
        self._cache_wpoints       = None

    # ================================================================================
    # Wrap a collection of wrapped objects

    def erase_cache(self):
        super().erase_cache()

        if self._cache_wbezier_points is not None:
            self._cache_wbezier_points.erase_cache()
            self._cache_wbezier_points = None

        if self._cache_wpoints is not None:
            self._cache_wpoints.erase_cache()
            self._cache_wpoints = None

    @property
    def wbezier_points(self): # Array of WBezierSplinePoint
        arrayof = self._cache_wbezier_points
        if arrayof is None:
            arrayof = ArrayOfWBezierSplinePoint(self)
            arrayof.array = self.obj.bezier_points
        self._cache_wbezier_points = arrayof
        return arrayof

    @property
    def wpoints(self): # Array of WSplinePoint
        arrayof = self._cache_wpoints
        if arrayof is None:
            arrayof = ArrayOfWSplinePoint(self)
            arrayof.array = self.obj.points
        self._cache_wpoints = arrayof
        return arrayof


    # ================================================================================
    # Direct properties wrappers

    @property
    def bezier_points(self): # AWBezierSplinePoint
        return self.obj.bezier_points

    @bezier_points.setter
    def bezier_points(self, value): # AWBezierSplinePoint
        self.obj.bezier_points = value

    @property
    def character_index(self) -> int:
        return self.obj.character_index

    @character_index.setter
    def character_index(self, value): # int
        self.obj.character_index = value

    @property
    def material_index(self) -> int:
        return self.obj.material_index

    @material_index.setter
    def material_index(self, value): # int
        self.obj.material_index = value

    @property
    def order_u(self) -> int:
        return self.obj.order_u

    @order_u.setter
    def order_u(self, value): # int
        self.obj.order_u = value

    @property
    def order_v(self) -> int:
        return self.obj.order_v

    @order_v.setter
    def order_v(self, value): # int
        self.obj.order_v = value

    @property
    def point_count_u(self) -> int:
        return self.obj.point_count_u

    @point_count_u.setter
    def point_count_u(self, value): # int
        self.obj.point_count_u = value

    @property
    def point_count_v(self) -> int:
        return self.obj.point_count_v

    @point_count_v.setter
    def point_count_v(self, value): # int
        self.obj.point_count_v = value

    @property
    def points(self): # AWSplinePoint
        return self.obj.points

    @points.setter
    def points(self, value): # AWSplinePoint
        self.obj.points = value

    @property
    def radius_interpolation(self) -> str:
        return self.obj.radius_interpolation

    @radius_interpolation.setter
    def radius_interpolation(self, value): # str
        self.obj.radius_interpolation = value

    @property
    def resolution_u(self) -> int:
        return self.obj.resolution_u

    @resolution_u.setter
    def resolution_u(self, value): # int
        self.obj.resolution_u = value

    @property
    def resolution_v(self) -> int:
        return self.obj.resolution_v

    @resolution_v.setter
    def resolution_v(self, value): # int
        self.obj.resolution_v = value

    @property
    def type(self) -> str:
        return self.obj.type

    @type.setter
    def type(self, value): # str
        self.obj.type = value

    @property
    def use_bezier_u(self) -> bool:
        return self.obj.use_bezier_u

    @use_bezier_u.setter
    def use_bezier_u(self, value): # bool
        self.obj.use_bezier_u = value

    @property
    def use_bezier_v(self) -> bool:
        return self.obj.use_bezier_v

    @use_bezier_v.setter
    def use_bezier_v(self, value): # bool
        self.obj.use_bezier_v = value

    @property
    def use_cyclic_u(self) -> bool:
        return self.obj.use_cyclic_u

    @use_cyclic_u.setter
    def use_cyclic_u(self, value): # bool
        self.obj.use_cyclic_u = value

    @property
    def use_cyclic_v(self) -> bool:
        return self.obj.use_cyclic_v

    @use_cyclic_v.setter
    def use_cyclic_v(self, value): # bool
        self.obj.use_cyclic_v = value

    @property
    def use_endpoint_u(self) -> bool:
        return self.obj.use_endpoint_u

    @use_endpoint_u.setter
    def use_endpoint_u(self, value): # bool
        self.obj.use_endpoint_u = value

    @property
    def use_endpoint_v(self) -> bool:
        return self.obj.use_endpoint_v

    @use_endpoint_v.setter
    def use_endpoint_v(self, value): # bool
        self.obj.use_endpoint_v = value

    @property
    def use_smooth(self) -> bool:
        return self.obj.use_smooth

    @use_smooth.setter
    def use_smooth(self, value): # bool
        self.obj.use_smooth = value



# ************************************************************************************
# Class ArrayOf WSpline automatically generated by wa_sourcegen

class ArrayOfWSpline(ArrayOf):

    # ================================================================================
    # Initialization
    # Create the cache properties

    def __init__(self, wowner):
        super().__init__(WSpline, wowner)

        self._cache_character_indices            = None
        self._cache_material_indices             = None
        self._cache_order_us                     = None
        self._cache_order_vs                     = None
        self._cache_point_count_us               = None
        self._cache_point_count_vs               = None
        self._cache_radius_interpolations        = None
        self._cache_resolution_us                = None
        self._cache_resolution_vs                = None
        self._cache_types                        = None
        self._cache_use_bezier_us                = None
        self._cache_use_bezier_vs                = None
        self._cache_use_cyclic_us                = None
        self._cache_use_cyclic_vs                = None
        self._cache_use_endpoint_us              = None
        self._cache_use_endpoint_vs              = None
        self._cache_use_smooths                  = None

    # ================================================================================
    # Erase cache
    def erase_cache(self):
        super().erase_cache()

        self._cache_character_indices            = None
        self._cache_material_indices             = None
        self._cache_order_us                     = None
        self._cache_order_vs                     = None
        self._cache_point_count_us               = None
        self._cache_point_count_vs               = None
        self._cache_radius_interpolations        = None
        self._cache_resolution_us                = None
        self._cache_resolution_vs                = None
        self._cache_types                        = None
        self._cache_use_bezier_us                = None
        self._cache_use_bezier_vs                = None
        self._cache_use_cyclic_us                = None
        self._cache_use_cyclic_vs                = None
        self._cache_use_endpoint_us              = None
        self._cache_use_endpoint_vs              = None
        self._cache_use_smooths                  = None

    # ================================================================================
    # Vectorized access to properties in collection of wrapped classes

    @property
    def character_indices(self): # array of int
        values = self._cache_character_indices
        if values is None:
            values = np.empty(len(self), np.int)
            for i, obj in enumerate(self._array):
                values[i] = obj.character_index
            self._cache_character_indices = values
        return values

    @character_indices.setter
    def character_indices(self, values): # array of int
        self._cache_character_indices = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_character_indices):
            obj.character_index = v

    @property
    def material_indices(self): # array of int
        values = self._cache_material_indices
        if values is None:
            values = np.empty(len(self), np.int)
            for i, obj in enumerate(self._array):
                values[i] = obj.material_index
            self._cache_material_indices = values
        return values

    @material_indices.setter
    def material_indices(self, values): # array of int
        self._cache_material_indices = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_material_indices):
            obj.material_index = v

    @property
    def order_us(self): # array of int
        values = self._cache_order_us
        if values is None:
            values = np.empty(len(self), np.int)
            for i, obj in enumerate(self._array):
                values[i] = obj.order_u
            self._cache_order_us = values
        return values

    @order_us.setter
    def order_us(self, values): # array of int
        self._cache_order_us = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_order_us):
            obj.order_u = v

    @property
    def order_vs(self): # array of int
        values = self._cache_order_vs
        if values is None:
            values = np.empty(len(self), np.int)
            for i, obj in enumerate(self._array):
                values[i] = obj.order_v
            self._cache_order_vs = values
        return values

    @order_vs.setter
    def order_vs(self, values): # array of int
        self._cache_order_vs = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_order_vs):
            obj.order_v = v

    @property
    def point_count_us(self): # array of int
        values = self._cache_point_count_us
        if values is None:
            values = np.empty(len(self), np.int)
            for i, obj in enumerate(self._array):
                values[i] = obj.point_count_u
            self._cache_point_count_us = values
        return values

    @point_count_us.setter
    def point_count_us(self, values): # array of int
        self._cache_point_count_us = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_point_count_us):
            obj.point_count_u = v

    @property
    def point_count_vs(self): # array of int
        values = self._cache_point_count_vs
        if values is None:
            values = np.empty(len(self), np.int)
            for i, obj in enumerate(self._array):
                values[i] = obj.point_count_v
            self._cache_point_count_vs = values
        return values

    @point_count_vs.setter
    def point_count_vs(self, values): # array of int
        self._cache_point_count_vs = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_point_count_vs):
            obj.point_count_v = v

    @property
    def radius_interpolations(self): # array of str
        values = self._cache_radius_interpolations
        if values is None:
            values = np.empty(len(self), np.object)
            for i, obj in enumerate(self._array):
                values[i] = obj.radius_interpolation
            self._cache_radius_interpolations = values
        return values

    @radius_interpolations.setter
    def radius_interpolations(self, values): # array of str
        self._cache_radius_interpolations = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_radius_interpolations):
            obj.radius_interpolation = v

    @property
    def resolution_us(self): # array of int
        values = self._cache_resolution_us
        if values is None:
            values = np.empty(len(self), np.int)
            for i, obj in enumerate(self._array):
                values[i] = obj.resolution_u
            self._cache_resolution_us = values
        return values

    @resolution_us.setter
    def resolution_us(self, values): # array of int
        self._cache_resolution_us = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_resolution_us):
            obj.resolution_u = v

    @property
    def resolution_vs(self): # array of int
        values = self._cache_resolution_vs
        if values is None:
            values = np.empty(len(self), np.int)
            for i, obj in enumerate(self._array):
                values[i] = obj.resolution_v
            self._cache_resolution_vs = values
        return values

    @resolution_vs.setter
    def resolution_vs(self, values): # array of int
        self._cache_resolution_vs = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_resolution_vs):
            obj.resolution_v = v

    @property
    def types(self): # array of str
        values = self._cache_types
        if values is None:
            values = np.empty(len(self), np.object)
            for i, obj in enumerate(self._array):
                values[i] = obj.type
            self._cache_types = values
        return values

    @types.setter
    def types(self, values): # array of str
        self._cache_types = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_types):
            obj.type = v

    @property
    def use_bezier_us(self): # array of bool
        values = self._cache_use_bezier_us
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.use_bezier_u
            self._cache_use_bezier_us = values
        return values

    @use_bezier_us.setter
    def use_bezier_us(self, values): # array of bool
        self._cache_use_bezier_us = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_use_bezier_us):
            obj.use_bezier_u = v

    @property
    def use_bezier_vs(self): # array of bool
        values = self._cache_use_bezier_vs
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.use_bezier_v
            self._cache_use_bezier_vs = values
        return values

    @use_bezier_vs.setter
    def use_bezier_vs(self, values): # array of bool
        self._cache_use_bezier_vs = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_use_bezier_vs):
            obj.use_bezier_v = v

    @property
    def use_cyclic_us(self): # array of bool
        values = self._cache_use_cyclic_us
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.use_cyclic_u
            self._cache_use_cyclic_us = values
        return values

    @use_cyclic_us.setter
    def use_cyclic_us(self, values): # array of bool
        self._cache_use_cyclic_us = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_use_cyclic_us):
            obj.use_cyclic_u = v

    @property
    def use_cyclic_vs(self): # array of bool
        values = self._cache_use_cyclic_vs
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.use_cyclic_v
            self._cache_use_cyclic_vs = values
        return values

    @use_cyclic_vs.setter
    def use_cyclic_vs(self, values): # array of bool
        self._cache_use_cyclic_vs = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_use_cyclic_vs):
            obj.use_cyclic_v = v

    @property
    def use_endpoint_us(self): # array of bool
        values = self._cache_use_endpoint_us
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.use_endpoint_u
            self._cache_use_endpoint_us = values
        return values

    @use_endpoint_us.setter
    def use_endpoint_us(self, values): # array of bool
        self._cache_use_endpoint_us = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_use_endpoint_us):
            obj.use_endpoint_u = v

    @property
    def use_endpoint_vs(self): # array of bool
        values = self._cache_use_endpoint_vs
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.use_endpoint_v
            self._cache_use_endpoint_vs = values
        return values

    @use_endpoint_vs.setter
    def use_endpoint_vs(self, values): # array of bool
        self._cache_use_endpoint_vs = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_use_endpoint_vs):
            obj.use_endpoint_v = v

    @property
    def use_smooths(self): # array of bool
        values = self._cache_use_smooths
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.use_smooth
            self._cache_use_smooths = values
        return values

    @use_smooths.setter
    def use_smooths(self, values): # array of bool
        self._cache_use_smooths = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_use_smooths):
            obj.use_smooth = v


# ************************************************************************************
# Class WCurve automatically generated by wa_sourcegen

class WCurve(Wrapper):

    # ================================================================================
    # Initialization
    # Create cache properties

    def __init__(self, obj, wowner):
        super().__init__(obj, wowner)

        self._cache_wsplines      = None

    # ================================================================================
    # Wrap a collection of wrapped objects

    def erase_cache(self):
        super().erase_cache()

        if self._cache_wsplines is not None:
            self._cache_wsplines.erase_cache()
            self._cache_wsplines = None

    @property
    def wsplines(self): # Array of WSpline
        arrayof = self._cache_wsplines
        if arrayof is None:
            arrayof = ArrayOfWSpline(self)
            arrayof.array = self.obj.splines
        self._cache_wsplines = arrayof
        return arrayof


    # ================================================================================
    # Direct properties wrappers

    @property
    def bevel_depth(self) -> float:
        return self.obj.bevel_depth

    @bevel_depth.setter
    def bevel_depth(self, value): # float
        self.obj.bevel_depth = value

    @property
    def bevel_factor_end(self) -> float:
        return self.obj.bevel_factor_end

    @bevel_factor_end.setter
    def bevel_factor_end(self, value): # float
        self.obj.bevel_factor_end = value

    @property
    def bevel_factor_start(self) -> float:
        return self.obj.bevel_factor_start

    @bevel_factor_start.setter
    def bevel_factor_start(self, value): # float
        self.obj.bevel_factor_start = value

    @property
    def bevel_object(self): # WCurve
        return self.obj.bevel_object

    @bevel_object.setter
    def bevel_object(self, value): # WCurve
        self.obj.bevel_object = value

    @property
    def bevel_resolution(self) -> int:
        return self.obj.bevel_resolution

    @bevel_resolution.setter
    def bevel_resolution(self, value): # int
        self.obj.bevel_resolution = value

    @property
    def dimensions(self) -> str:
        return self.obj.dimensions

    @dimensions.setter
    def dimensions(self, value): # str
        self.obj.dimensions = value

    @property
    def eval_time(self) -> float:
        return self.obj.eval_time

    @eval_time.setter
    def eval_time(self, value): # float
        self.obj.eval_time = value

    @property
    def extrude(self) -> float:
        return self.obj.extrude

    @extrude.setter
    def extrude(self, value): # float
        self.obj.extrude = value

    @property
    def fill_mode(self) -> str:
        return self.obj.fill_mode

    @fill_mode.setter
    def fill_mode(self, value): # str
        self.obj.fill_mode = value

    @property
    def offset(self) -> float:
        return self.obj.offset

    @offset.setter
    def offset(self, value): # float
        self.obj.offset = value

    @property
    def path_duration(self) -> int:
        return self.obj.path_duration

    @path_duration.setter
    def path_duration(self, value): # int
        self.obj.path_duration = value

    @property
    def render_resolution_u(self) -> int:
        return self.obj.render_resolution_u

    @render_resolution_u.setter
    def render_resolution_u(self, value): # int
        self.obj.render_resolution_u = value

    @property
    def render_resolution_v(self) -> int:
        return self.obj.render_resolution_v

    @render_resolution_v.setter
    def render_resolution_v(self, value): # int
        self.obj.render_resolution_v = value

    @property
    def resolution_u(self) -> int:
        return self.obj.resolution_u

    @resolution_u.setter
    def resolution_u(self, value): # int
        self.obj.resolution_u = value

    @property
    def resolution_v(self) -> int:
        return self.obj.resolution_v

    @resolution_v.setter
    def resolution_v(self, value): # int
        self.obj.resolution_v = value

    @property
    def splines(self): # AWSpline
        return self.obj.splines

    @splines.setter
    def splines(self, value): # AWSpline
        self.obj.splines = value

    @property
    def taper_object(self): # WCurve
        return self.obj.taper_object

    @taper_object.setter
    def taper_object(self, value): # WCurve
        self.obj.taper_object = value

    @property
    def twist_smooth(self) -> float:
        return self.obj.twist_smooth

    @twist_smooth.setter
    def twist_smooth(self, value): # float
        self.obj.twist_smooth = value

    @property
    def use_auto_texspace(self) -> bool:
        return self.obj.use_auto_texspace

    @use_auto_texspace.setter
    def use_auto_texspace(self, value): # bool
        self.obj.use_auto_texspace = value

    @property
    def use_deform_bounds(self) -> bool:
        return self.obj.use_deform_bounds

    @use_deform_bounds.setter
    def use_deform_bounds(self, value): # bool
        self.obj.use_deform_bounds = value

    @property
    def use_fill_caps(self) -> bool:
        return self.obj.use_fill_caps

    @use_fill_caps.setter
    def use_fill_caps(self, value): # bool
        self.obj.use_fill_caps = value

    @property
    def use_fill_deform(self) -> bool:
        return self.obj.use_fill_deform

    @use_fill_deform.setter
    def use_fill_deform(self, value): # bool
        self.obj.use_fill_deform = value

    @property
    def use_map_taper(self) -> bool:
        return self.obj.use_map_taper

    @use_map_taper.setter
    def use_map_taper(self, value): # bool
        self.obj.use_map_taper = value

    @property
    def use_path_follow(self) -> bool:
        return self.obj.use_path_follow

    @use_path_follow.setter
    def use_path_follow(self, value): # bool
        self.obj.use_path_follow = value

    @property
    def use_path(self) -> bool:
        return self.obj.use_path

    @use_path.setter
    def use_path(self, value): # bool
        self.obj.use_path = value

    @property
    def use_radius(self) -> bool:
        return self.obj.use_radius

    @use_radius.setter
    def use_radius(self, value): # bool
        self.obj.use_radius = value

    @property
    def use_stretch(self) -> bool:
        return self.obj.use_stretch

    @use_stretch.setter
    def use_stretch(self, value): # bool
        self.obj.use_stretch = value



# ************************************************************************************
# Class ArrayOf WCurve automatically generated by wa_sourcegen

class ArrayOfWCurve(ArrayOf):

    # ================================================================================
    # Initialization
    # Create the cache properties

    def __init__(self, wowner):
        super().__init__(WCurve, wowner)

        self._cache_bevel_depths                 = None
        self._cache_bevel_factor_ends            = None
        self._cache_bevel_factor_starts          = None
        self._cache_bevel_resolutions            = None
        self._cache_dimensions_s                 = None
        self._cache_eval_times                   = None
        self._cache_extrudes                     = None
        self._cache_fill_modes                   = None
        self._cache_offsets                      = None
        self._cache_path_durations               = None
        self._cache_render_resolution_us         = None
        self._cache_render_resolution_vs         = None
        self._cache_resolution_us                = None
        self._cache_resolution_vs                = None
        self._cache_twist_smooths                = None
        self._cache_use_auto_texspaces           = None
        self._cache_use_deform_bounds_s          = None
        self._cache_use_fill_caps_s              = None
        self._cache_use_fill_deforms             = None
        self._cache_use_map_tapers               = None
        self._cache_use_path_follows             = None
        self._cache_use_paths                    = None
        self._cache_use_radius_s                 = None
        self._cache_use_stretchs                 = None

    # ================================================================================
    # Erase cache
    def erase_cache(self):
        super().erase_cache()

        self._cache_bevel_depths                 = None
        self._cache_bevel_factor_ends            = None
        self._cache_bevel_factor_starts          = None
        self._cache_bevel_resolutions            = None
        self._cache_dimensions_s                 = None
        self._cache_eval_times                   = None
        self._cache_extrudes                     = None
        self._cache_fill_modes                   = None
        self._cache_offsets                      = None
        self._cache_path_durations               = None
        self._cache_render_resolution_us         = None
        self._cache_render_resolution_vs         = None
        self._cache_resolution_us                = None
        self._cache_resolution_vs                = None
        self._cache_twist_smooths                = None
        self._cache_use_auto_texspaces           = None
        self._cache_use_deform_bounds_s          = None
        self._cache_use_fill_caps_s              = None
        self._cache_use_fill_deforms             = None
        self._cache_use_map_tapers               = None
        self._cache_use_path_follows             = None
        self._cache_use_paths                    = None
        self._cache_use_radius_s                 = None
        self._cache_use_stretchs                 = None

    # ================================================================================
    # Vectorized access to properties in collection of wrapped classes

    @property
    def bevel_depths(self): # array of float
        values = self._cache_bevel_depths
        if values is None:
            values = np.empty(len(self), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.bevel_depth
            self._cache_bevel_depths = values
        return values

    @bevel_depths.setter
    def bevel_depths(self, values): # array of float
        self._cache_bevel_depths = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_bevel_depths):
            obj.bevel_depth = v

    @property
    def bevel_factor_ends(self): # array of float
        values = self._cache_bevel_factor_ends
        if values is None:
            values = np.empty(len(self), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.bevel_factor_end
            self._cache_bevel_factor_ends = values
        return values

    @bevel_factor_ends.setter
    def bevel_factor_ends(self, values): # array of float
        self._cache_bevel_factor_ends = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_bevel_factor_ends):
            obj.bevel_factor_end = v

    @property
    def bevel_factor_starts(self): # array of float
        values = self._cache_bevel_factor_starts
        if values is None:
            values = np.empty(len(self), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.bevel_factor_start
            self._cache_bevel_factor_starts = values
        return values

    @bevel_factor_starts.setter
    def bevel_factor_starts(self, values): # array of float
        self._cache_bevel_factor_starts = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_bevel_factor_starts):
            obj.bevel_factor_start = v

    @property
    def bevel_resolutions(self): # array of int
        values = self._cache_bevel_resolutions
        if values is None:
            values = np.empty(len(self), np.int)
            for i, obj in enumerate(self._array):
                values[i] = obj.bevel_resolution
            self._cache_bevel_resolutions = values
        return values

    @bevel_resolutions.setter
    def bevel_resolutions(self, values): # array of int
        self._cache_bevel_resolutions = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_bevel_resolutions):
            obj.bevel_resolution = v

    @property
    def dimensions_s(self): # array of str
        values = self._cache_dimensions_s
        if values is None:
            values = np.empty(len(self), np.object)
            for i, obj in enumerate(self._array):
                values[i] = obj.dimensions
            self._cache_dimensions_s = values
        return values

    @dimensions_s.setter
    def dimensions_s(self, values): # array of str
        self._cache_dimensions_s = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_dimensions_s):
            obj.dimensions = v

    @property
    def eval_times(self): # array of float
        values = self._cache_eval_times
        if values is None:
            values = np.empty(len(self), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.eval_time
            self._cache_eval_times = values
        return values

    @eval_times.setter
    def eval_times(self, values): # array of float
        self._cache_eval_times = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_eval_times):
            obj.eval_time = v

    @property
    def extrudes(self): # array of float
        values = self._cache_extrudes
        if values is None:
            values = np.empty(len(self), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.extrude
            self._cache_extrudes = values
        return values

    @extrudes.setter
    def extrudes(self, values): # array of float
        self._cache_extrudes = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_extrudes):
            obj.extrude = v

    @property
    def fill_modes(self): # array of str
        values = self._cache_fill_modes
        if values is None:
            values = np.empty(len(self), np.object)
            for i, obj in enumerate(self._array):
                values[i] = obj.fill_mode
            self._cache_fill_modes = values
        return values

    @fill_modes.setter
    def fill_modes(self, values): # array of str
        self._cache_fill_modes = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_fill_modes):
            obj.fill_mode = v

    @property
    def offsets(self): # array of float
        values = self._cache_offsets
        if values is None:
            values = np.empty(len(self), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.offset
            self._cache_offsets = values
        return values

    @offsets.setter
    def offsets(self, values): # array of float
        self._cache_offsets = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_offsets):
            obj.offset = v

    @property
    def path_durations(self): # array of int
        values = self._cache_path_durations
        if values is None:
            values = np.empty(len(self), np.int)
            for i, obj in enumerate(self._array):
                values[i] = obj.path_duration
            self._cache_path_durations = values
        return values

    @path_durations.setter
    def path_durations(self, values): # array of int
        self._cache_path_durations = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_path_durations):
            obj.path_duration = v

    @property
    def render_resolution_us(self): # array of int
        values = self._cache_render_resolution_us
        if values is None:
            values = np.empty(len(self), np.int)
            for i, obj in enumerate(self._array):
                values[i] = obj.render_resolution_u
            self._cache_render_resolution_us = values
        return values

    @render_resolution_us.setter
    def render_resolution_us(self, values): # array of int
        self._cache_render_resolution_us = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_render_resolution_us):
            obj.render_resolution_u = v

    @property
    def render_resolution_vs(self): # array of int
        values = self._cache_render_resolution_vs
        if values is None:
            values = np.empty(len(self), np.int)
            for i, obj in enumerate(self._array):
                values[i] = obj.render_resolution_v
            self._cache_render_resolution_vs = values
        return values

    @render_resolution_vs.setter
    def render_resolution_vs(self, values): # array of int
        self._cache_render_resolution_vs = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_render_resolution_vs):
            obj.render_resolution_v = v

    @property
    def resolution_us(self): # array of int
        values = self._cache_resolution_us
        if values is None:
            values = np.empty(len(self), np.int)
            for i, obj in enumerate(self._array):
                values[i] = obj.resolution_u
            self._cache_resolution_us = values
        return values

    @resolution_us.setter
    def resolution_us(self, values): # array of int
        self._cache_resolution_us = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_resolution_us):
            obj.resolution_u = v

    @property
    def resolution_vs(self): # array of int
        values = self._cache_resolution_vs
        if values is None:
            values = np.empty(len(self), np.int)
            for i, obj in enumerate(self._array):
                values[i] = obj.resolution_v
            self._cache_resolution_vs = values
        return values

    @resolution_vs.setter
    def resolution_vs(self, values): # array of int
        self._cache_resolution_vs = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_resolution_vs):
            obj.resolution_v = v

    @property
    def twist_smooths(self): # array of float
        values = self._cache_twist_smooths
        if values is None:
            values = np.empty(len(self), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.twist_smooth
            self._cache_twist_smooths = values
        return values

    @twist_smooths.setter
    def twist_smooths(self, values): # array of float
        self._cache_twist_smooths = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_twist_smooths):
            obj.twist_smooth = v

    @property
    def use_auto_texspaces(self): # array of bool
        values = self._cache_use_auto_texspaces
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.use_auto_texspace
            self._cache_use_auto_texspaces = values
        return values

    @use_auto_texspaces.setter
    def use_auto_texspaces(self, values): # array of bool
        self._cache_use_auto_texspaces = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_use_auto_texspaces):
            obj.use_auto_texspace = v

    @property
    def use_deform_bounds_s(self): # array of bool
        values = self._cache_use_deform_bounds_s
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.use_deform_bounds
            self._cache_use_deform_bounds_s = values
        return values

    @use_deform_bounds_s.setter
    def use_deform_bounds_s(self, values): # array of bool
        self._cache_use_deform_bounds_s = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_use_deform_bounds_s):
            obj.use_deform_bounds = v

    @property
    def use_fill_caps_s(self): # array of bool
        values = self._cache_use_fill_caps_s
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.use_fill_caps
            self._cache_use_fill_caps_s = values
        return values

    @use_fill_caps_s.setter
    def use_fill_caps_s(self, values): # array of bool
        self._cache_use_fill_caps_s = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_use_fill_caps_s):
            obj.use_fill_caps = v

    @property
    def use_fill_deforms(self): # array of bool
        values = self._cache_use_fill_deforms
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.use_fill_deform
            self._cache_use_fill_deforms = values
        return values

    @use_fill_deforms.setter
    def use_fill_deforms(self, values): # array of bool
        self._cache_use_fill_deforms = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_use_fill_deforms):
            obj.use_fill_deform = v

    @property
    def use_map_tapers(self): # array of bool
        values = self._cache_use_map_tapers
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.use_map_taper
            self._cache_use_map_tapers = values
        return values

    @use_map_tapers.setter
    def use_map_tapers(self, values): # array of bool
        self._cache_use_map_tapers = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_use_map_tapers):
            obj.use_map_taper = v

    @property
    def use_path_follows(self): # array of bool
        values = self._cache_use_path_follows
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.use_path_follow
            self._cache_use_path_follows = values
        return values

    @use_path_follows.setter
    def use_path_follows(self, values): # array of bool
        self._cache_use_path_follows = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_use_path_follows):
            obj.use_path_follow = v

    @property
    def use_paths(self): # array of bool
        values = self._cache_use_paths
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.use_path
            self._cache_use_paths = values
        return values

    @use_paths.setter
    def use_paths(self, values): # array of bool
        self._cache_use_paths = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_use_paths):
            obj.use_path = v

    @property
    def use_radius_s(self): # array of bool
        values = self._cache_use_radius_s
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.use_radius
            self._cache_use_radius_s = values
        return values

    @use_radius_s.setter
    def use_radius_s(self, values): # array of bool
        self._cache_use_radius_s = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_use_radius_s):
            obj.use_radius = v

    @property
    def use_stretchs(self): # array of bool
        values = self._cache_use_stretchs
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.use_stretch
            self._cache_use_stretchs = values
        return values

    @use_stretchs.setter
    def use_stretchs(self, values): # array of bool
        self._cache_use_stretchs = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_use_stretchs):
            obj.use_stretch = v


# ************************************************************************************
# Class WObject automatically generated by wa_sourcegen

class WObject(Wrapper):

    # ================================================================================
    # Some useful shortcuts

    @property
    def x(self): # float
        return self.obj.location.x

    @x.setter
    def x(self, value): # float
        self.obj.location.x = value

    @property
    def y(self): # float
        return self.obj.location.y

    @y.setter
    def y(self, value): # float
        self.obj.location.y = value

    @property
    def z(self): # float
        return self.obj.location.z

    @z.setter
    def z(self, value): # float
        self.obj.location.z = value

    @property
    def sx(self): # float
        return self.obj.scale.x

    @sx.setter
    def sx(self, value): # float
        self.obj.scale.x = value

    @property
    def sy(self): # float
        return self.obj.scale.y

    @sy.setter
    def sy(self, value): # float
        self.obj.scale.y = value

    @property
    def sz(self): # float
        return self.obj.scale.z

    @sz.setter
    def sz(self, value): # float
        self.obj.scale.z = value

    @property
    def rx(self): # float
        return self.obj.rotation_euler.x

    @rx.setter
    def rx(self, value): # float
        self.obj.rotation_euler.x = value

    @property
    def ry(self): # float
        return self.obj.rotation_euler.y

    @ry.setter
    def ry(self, value): # float
        self.obj.rotation_euler.y = value

    @property
    def rz(self): # float
        return self.obj.rotation_euler.z

    @rz.setter
    def rz(self, value): # float
        self.obj.rotation_euler.z = value


    # ================================================================================
    # Direct properties wrappers

    @property
    def active_material_index(self) -> int:
        return self.obj.active_material_index

    @active_material_index.setter
    def active_material_index(self, value): # int
        self.obj.active_material_index = value

    @property
    def active_shape_key_index(self) -> int:
        return self.obj.active_shape_key_index

    @active_shape_key_index.setter
    def active_shape_key_index(self, value): # int
        self.obj.active_shape_key_index = value

    @property
    def bound_box(self): # bbox
        return self.obj.bound_box

    @bound_box.setter
    def bound_box(self, value): # bbox
        self.obj.bound_box = value

    @property
    def color(self): # V4
        return self.obj.color

    @color.setter
    def color(self, value): # V4
        self.obj.color = value

    @property
    def delta_location(self): # V3
        return self.obj.delta_location

    @delta_location.setter
    def delta_location(self, value): # V3
        self.obj.delta_location = value

    @property
    def delta_rotation_euler(self): # V3
        return self.obj.delta_rotation_euler

    @delta_rotation_euler.setter
    def delta_rotation_euler(self, value): # V3
        self.obj.delta_rotation_euler = value

    @property
    def delta_rotation_quaternion(self): # V4
        return self.obj.delta_rotation_quaternion

    @delta_rotation_quaternion.setter
    def delta_rotation_quaternion(self, value): # V4
        self.obj.delta_rotation_quaternion = value

    @property
    def delta_scale(self): # V3
        return self.obj.delta_scale

    @delta_scale.setter
    def delta_scale(self, value): # V3
        self.obj.delta_scale = value

    @property
    def empty_display_size(self) -> float:
        return self.obj.empty_display_size

    @empty_display_size.setter
    def empty_display_size(self, value): # float
        self.obj.empty_display_size = value

    @property
    def empty_image_offset(self): # V2
        return self.obj.empty_image_offset

    @empty_image_offset.setter
    def empty_image_offset(self, value): # V2
        self.obj.empty_image_offset = value

    @property
    def dimensions(self): # V3
        return self.obj.dimensions

    @dimensions.setter
    def dimensions(self, value): # V3
        self.obj.dimensions = value

    @property
    def hide_render(self) -> bool:
        return self.obj.hide_render

    @hide_render.setter
    def hide_render(self, value): # bool
        self.obj.hide_render = value

    @property
    def hide_select(self) -> bool:
        return self.obj.hide_select

    @hide_select.setter
    def hide_select(self, value): # bool
        self.obj.hide_select = value

    @property
    def hide_viewport(self) -> bool:
        return self.obj.hide_viewport

    @hide_viewport.setter
    def hide_viewport(self, value): # bool
        self.obj.hide_viewport = value

    @property
    def instance_faces_scale(self) -> float:
        return self.obj.instance_faces_scale

    @instance_faces_scale.setter
    def instance_faces_scale(self, value): # float
        self.obj.instance_faces_scale = value

    @property
    def location(self): # V3
        return self.obj.location

    @location.setter
    def location(self, value): # V3
        self.obj.location = value

    @property
    def lock_scale(self) -> bool:
        return self.obj.lock_scale

    @lock_scale.setter
    def lock_scale(self, value): # bool
        self.obj.lock_scale = value

    @property
    def matrix_basis(self): # M4
        return self.obj.matrix_basis

    @matrix_basis.setter
    def matrix_basis(self, value): # M4
        self.obj.matrix_basis = value

    @property
    def matrix_local(self): # M4
        return self.obj.matrix_local

    @matrix_local.setter
    def matrix_local(self, value): # M4
        self.obj.matrix_local = value

    @property
    def matrix_parent_inverse(self): # M4
        return self.obj.matrix_parent_inverse

    @matrix_parent_inverse.setter
    def matrix_parent_inverse(self, value): # M4
        self.obj.matrix_parent_inverse = value

    @property
    def matrix_world(self): # M4
        return self.obj.matrix_world

    @matrix_world.setter
    def matrix_world(self, value): # M4
        self.obj.matrix_world = value

    @property
    def pass_index(self) -> int:
        return self.obj.pass_index

    @pass_index.setter
    def pass_index(self, value): # int
        self.obj.pass_index = value

    @property
    def rotation_euler(self): # V3
        return self.obj.rotation_euler

    @rotation_euler.setter
    def rotation_euler(self, value): # V3
        self.obj.rotation_euler = value

    @property
    def rotation_mode(self) -> str:
        return self.obj.rotation_mode

    @rotation_mode.setter
    def rotation_mode(self, value): # str
        self.obj.rotation_mode = value

    @property
    def rotation_quaternion(self): # V4
        return self.obj.rotation_quaternion

    @rotation_quaternion.setter
    def rotation_quaternion(self, value): # V4
        self.obj.rotation_quaternion = value

    @property
    def scale(self): # V3
        return self.obj.scale

    @scale.setter
    def scale(self, value): # V3
        self.obj.scale = value

    @property
    def show_all_edges(self) -> bool:
        return self.obj.show_all_edges

    @show_all_edges.setter
    def show_all_edges(self, value): # bool
        self.obj.show_all_edges = value

    @property
    def show_axis(self) -> bool:
        return self.obj.show_axis

    @show_axis.setter
    def show_axis(self, value): # bool
        self.obj.show_axis = value

    @property
    def show_bounds(self) -> bool:
        return self.obj.show_bounds

    @show_bounds.setter
    def show_bounds(self, value): # bool
        self.obj.show_bounds = value

    @property
    def show_empty_image_only_axis_aligned(self) -> bool:
        return self.obj.show_empty_image_only_axis_aligned

    @show_empty_image_only_axis_aligned.setter
    def show_empty_image_only_axis_aligned(self, value): # bool
        self.obj.show_empty_image_only_axis_aligned = value

    @property
    def show_empty_image_orthographic(self) -> bool:
        return self.obj.show_empty_image_orthographic

    @show_empty_image_orthographic.setter
    def show_empty_image_orthographic(self, value): # bool
        self.obj.show_empty_image_orthographic = value

    @property
    def show_empty_image_perspective(self) -> bool:
        return self.obj.show_empty_image_perspective

    @show_empty_image_perspective.setter
    def show_empty_image_perspective(self, value): # bool
        self.obj.show_empty_image_perspective = value

    @property
    def show_in_front(self) -> bool:
        return self.obj.show_in_front

    @show_in_front.setter
    def show_in_front(self, value): # bool
        self.obj.show_in_front = value

    @property
    def show_instancer_for_render(self) -> bool:
        return self.obj.show_instancer_for_render

    @show_instancer_for_render.setter
    def show_instancer_for_render(self, value): # bool
        self.obj.show_instancer_for_render = value

    @property
    def show_instancer_for_viewport(self) -> bool:
        return self.obj.show_instancer_for_viewport

    @show_instancer_for_viewport.setter
    def show_instancer_for_viewport(self, value): # bool
        self.obj.show_instancer_for_viewport = value

    @property
    def show_name(self) -> bool:
        return self.obj.show_name

    @show_name.setter
    def show_name(self, value): # bool
        self.obj.show_name = value

    @property
    def show_only_shape_key(self) -> bool:
        return self.obj.show_only_shape_key

    @show_only_shape_key.setter
    def show_only_shape_key(self, value): # bool
        self.obj.show_only_shape_key = value

    @property
    def show_texture_space(self) -> bool:
        return self.obj.show_texture_space

    @show_texture_space.setter
    def show_texture_space(self, value): # bool
        self.obj.show_texture_space = value

    @property
    def show_transparent(self) -> bool:
        return self.obj.show_transparent

    @show_transparent.setter
    def show_transparent(self, value): # bool
        self.obj.show_transparent = value

    @property
    def show_wire(self) -> bool:
        return self.obj.show_wire

    @show_wire.setter
    def show_wire(self, value): # bool
        self.obj.show_wire = value

    @property
    def track_axis(self) -> str:
        return self.obj.track_axis

    @track_axis.setter
    def track_axis(self, value): # str
        self.obj.track_axis = value

    @property
    def type(self) -> str:
        return self.obj.type

    @type.setter
    def type(self, value): # str
        self.obj.type = value

    @property
    def up_axis(self) -> str:
        return self.obj.up_axis

    @up_axis.setter
    def up_axis(self, value): # str
        self.obj.up_axis = value

    @property
    def use_empty_image_alpha(self) -> bool:
        return self.obj.use_empty_image_alpha

    @use_empty_image_alpha.setter
    def use_empty_image_alpha(self, value): # bool
        self.obj.use_empty_image_alpha = value

    @property
    def use_instance_faces_scale(self) -> bool:
        return self.obj.use_instance_faces_scale

    @use_instance_faces_scale.setter
    def use_instance_faces_scale(self, value): # bool
        self.obj.use_instance_faces_scale = value

    @property
    def use_instance_vertices_rotation(self) -> bool:
        return self.obj.use_instance_vertices_rotation

    @use_instance_vertices_rotation.setter
    def use_instance_vertices_rotation(self, value): # bool
        self.obj.use_instance_vertices_rotation = value

    @property
    def use_shape_key_edit_mode(self) -> bool:
        return self.obj.use_shape_key_edit_mode

    @use_shape_key_edit_mode.setter
    def use_shape_key_edit_mode(self, value): # bool
        self.obj.use_shape_key_edit_mode = value



# ************************************************************************************
# Class ArrayOf WObject automatically generated by wa_sourcegen

class ArrayOfWObject(ArrayOf):

    # ================================================================================
    # Initialization
    # Create the cache properties

    def __init__(self, wowner):
        super().__init__(WObject, wowner)

        self._cache_active_material_indices      = None
        self._cache_active_shape_key_indices     = None
        self._cache_colors                       = None
        self._cache_delta_locations              = None
        self._cache_delta_rotation_eulers        = None
        self._cache_delta_rotation_quaternions   = None
        self._cache_delta_scales                 = None
        self._cache_empty_display_sizes          = None
        self._cache_empty_image_offsets          = None
        self._cache_dimensions_s                 = None
        self._cache_hide_renders                 = None
        self._cache_hide_selects                 = None
        self._cache_hide_viewports               = None
        self._cache_instance_faces_scales        = None
        self._cache_locations                    = None
        self._cache_lock_scales                  = None
        self._cache_pass_indices                 = None
        self._cache_rotation_eulers              = None
        self._cache_rotation_modes               = None
        self._cache_rotation_quaternions         = None
        self._cache_scales                       = None
        self._cache_show_all_edges_s             = None
        self._cache_show_axis_s                  = None
        self._cache_show_bounds_s                = None
        self._cache_show_empty_image_only_axis_aligneds = None
        self._cache_show_empty_image_orthographics = None
        self._cache_show_empty_image_perspectives = None
        self._cache_show_in_fronts               = None
        self._cache_show_instancer_for_renders   = None
        self._cache_show_instancer_for_viewports = None
        self._cache_show_names                   = None
        self._cache_show_only_shape_keys         = None
        self._cache_show_texture_spaces          = None
        self._cache_show_transparents            = None
        self._cache_show_wires                   = None
        self._cache_track_axis_s                 = None
        self._cache_types                        = None
        self._cache_up_axis_s                    = None
        self._cache_use_empty_image_alphas       = None
        self._cache_use_instance_faces_scales    = None
        self._cache_use_instance_vertices_rotations = None
        self._cache_use_shape_key_edit_modes     = None

    # ================================================================================
    # Erase cache
    def erase_cache(self):
        super().erase_cache()

        self._cache_active_material_indices      = None
        self._cache_active_shape_key_indices     = None
        self._cache_colors                       = None
        self._cache_delta_locations              = None
        self._cache_delta_rotation_eulers        = None
        self._cache_delta_rotation_quaternions   = None
        self._cache_delta_scales                 = None
        self._cache_empty_display_sizes          = None
        self._cache_empty_image_offsets          = None
        self._cache_dimensions_s                 = None
        self._cache_hide_renders                 = None
        self._cache_hide_selects                 = None
        self._cache_hide_viewports               = None
        self._cache_instance_faces_scales        = None
        self._cache_locations                    = None
        self._cache_lock_scales                  = None
        self._cache_pass_indices                 = None
        self._cache_rotation_eulers              = None
        self._cache_rotation_modes               = None
        self._cache_rotation_quaternions         = None
        self._cache_scales                       = None
        self._cache_show_all_edges_s             = None
        self._cache_show_axis_s                  = None
        self._cache_show_bounds_s                = None
        self._cache_show_empty_image_only_axis_aligneds = None
        self._cache_show_empty_image_orthographics = None
        self._cache_show_empty_image_perspectives = None
        self._cache_show_in_fronts               = None
        self._cache_show_instancer_for_renders   = None
        self._cache_show_instancer_for_viewports = None
        self._cache_show_names                   = None
        self._cache_show_only_shape_keys         = None
        self._cache_show_texture_spaces          = None
        self._cache_show_transparents            = None
        self._cache_show_wires                   = None
        self._cache_track_axis_s                 = None
        self._cache_types                        = None
        self._cache_up_axis_s                    = None
        self._cache_use_empty_image_alphas       = None
        self._cache_use_instance_faces_scales    = None
        self._cache_use_instance_vertices_rotations = None
        self._cache_use_shape_key_edit_modes     = None

    # ================================================================================
    # Vectorized access to properties in collection of wrapped classes

    @property
    def active_material_indices(self): # array of int
        values = self._cache_active_material_indices
        if values is None:
            values = np.empty(len(self), np.int)
            for i, obj in enumerate(self._array):
                values[i] = obj.active_material_index
            self._cache_active_material_indices = values
        return values

    @active_material_indices.setter
    def active_material_indices(self, values): # array of int
        self._cache_active_material_indices = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_active_material_indices):
            obj.active_material_index = v

    @property
    def active_shape_key_indices(self): # array of int
        values = self._cache_active_shape_key_indices
        if values is None:
            values = np.empty(len(self), np.int)
            for i, obj in enumerate(self._array):
                values[i] = obj.active_shape_key_index
            self._cache_active_shape_key_indices = values
        return values

    @active_shape_key_indices.setter
    def active_shape_key_indices(self, values): # array of int
        self._cache_active_shape_key_indices = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_active_shape_key_indices):
            obj.active_shape_key_index = v

    @property
    def colors(self): # array of V4
        values = self._cache_colors
        if values is None:
            values = np.empty((len(self), 4), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.color
            self._cache_colors = values
        return values

    @colors.setter
    def colors(self, values): # array of V4
        self._cache_colors = np.array(to_array(values, (len(self), 4), '4-vector or array of 4-vectors'))
        for obj, v in zip(self._array, self._cache_colors):
            obj.color = v

    @property
    def delta_locations(self): # array of V3
        values = self._cache_delta_locations
        if values is None:
            values = np.empty((len(self), 3), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.delta_location
            self._cache_delta_locations = values
        return values

    @delta_locations.setter
    def delta_locations(self, values): # array of V3
        self._cache_delta_locations = np.array(to_array(values, (len(self), 3), '3-vector or array of 3-vectors'))
        for obj, v in zip(self._array, self._cache_delta_locations):
            obj.delta_location = v

    @property
    def delta_rotation_eulers(self): # array of V3
        values = self._cache_delta_rotation_eulers
        if values is None:
            values = np.empty((len(self), 3), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.delta_rotation_euler
            self._cache_delta_rotation_eulers = values
        return values

    @delta_rotation_eulers.setter
    def delta_rotation_eulers(self, values): # array of V3
        self._cache_delta_rotation_eulers = np.array(to_array(values, (len(self), 3), '3-vector or array of 3-vectors'))
        for obj, v in zip(self._array, self._cache_delta_rotation_eulers):
            obj.delta_rotation_euler = v

    @property
    def delta_rotation_quaternions(self): # array of V4
        values = self._cache_delta_rotation_quaternions
        if values is None:
            values = np.empty((len(self), 4), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.delta_rotation_quaternion
            self._cache_delta_rotation_quaternions = values
        return values

    @delta_rotation_quaternions.setter
    def delta_rotation_quaternions(self, values): # array of V4
        self._cache_delta_rotation_quaternions = np.array(to_array(values, (len(self), 4), '4-vector or array of 4-vectors'))
        for obj, v in zip(self._array, self._cache_delta_rotation_quaternions):
            obj.delta_rotation_quaternion = v

    @property
    def delta_scales(self): # array of V3
        values = self._cache_delta_scales
        if values is None:
            values = np.empty((len(self), 3), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.delta_scale
            self._cache_delta_scales = values
        return values

    @delta_scales.setter
    def delta_scales(self, values): # array of V3
        self._cache_delta_scales = np.array(to_array(values, (len(self), 3), '3-vector or array of 3-vectors'))
        for obj, v in zip(self._array, self._cache_delta_scales):
            obj.delta_scale = v

    @property
    def empty_display_sizes(self): # array of float
        values = self._cache_empty_display_sizes
        if values is None:
            values = np.empty(len(self), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.empty_display_size
            self._cache_empty_display_sizes = values
        return values

    @empty_display_sizes.setter
    def empty_display_sizes(self, values): # array of float
        self._cache_empty_display_sizes = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_empty_display_sizes):
            obj.empty_display_size = v

    @property
    def empty_image_offsets(self): # array of V2
        values = self._cache_empty_image_offsets
        if values is None:
            values = np.empty((len(self), 2), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.empty_image_offset
            self._cache_empty_image_offsets = values
        return values

    @empty_image_offsets.setter
    def empty_image_offsets(self, values): # array of V2
        self._cache_empty_image_offsets = np.array(to_array(values, (len(self), 2), '2-vector or array of 2-vectors'))
        for obj, v in zip(self._array, self._cache_empty_image_offsets):
            obj.empty_image_offset = v

    @property
    def dimensions_s(self): # array of V3
        values = self._cache_dimensions_s
        if values is None:
            values = np.empty((len(self), 3), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.dimensions
            self._cache_dimensions_s = values
        return values

    @dimensions_s.setter
    def dimensions_s(self, values): # array of V3
        self._cache_dimensions_s = np.array(to_array(values, (len(self), 3), '3-vector or array of 3-vectors'))
        for obj, v in zip(self._array, self._cache_dimensions_s):
            obj.dimensions = v

    @property
    def hide_renders(self): # array of bool
        values = self._cache_hide_renders
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.hide_render
            self._cache_hide_renders = values
        return values

    @hide_renders.setter
    def hide_renders(self, values): # array of bool
        self._cache_hide_renders = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_hide_renders):
            obj.hide_render = v

    @property
    def hide_selects(self): # array of bool
        values = self._cache_hide_selects
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.hide_select
            self._cache_hide_selects = values
        return values

    @hide_selects.setter
    def hide_selects(self, values): # array of bool
        self._cache_hide_selects = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_hide_selects):
            obj.hide_select = v

    @property
    def hide_viewports(self): # array of bool
        values = self._cache_hide_viewports
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.hide_viewport
            self._cache_hide_viewports = values
        return values

    @hide_viewports.setter
    def hide_viewports(self, values): # array of bool
        self._cache_hide_viewports = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_hide_viewports):
            obj.hide_viewport = v

    @property
    def instance_faces_scales(self): # array of float
        values = self._cache_instance_faces_scales
        if values is None:
            values = np.empty(len(self), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.instance_faces_scale
            self._cache_instance_faces_scales = values
        return values

    @instance_faces_scales.setter
    def instance_faces_scales(self, values): # array of float
        self._cache_instance_faces_scales = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_instance_faces_scales):
            obj.instance_faces_scale = v

    @property
    def locations(self): # array of V3
        values = self._cache_locations
        if values is None:
            values = np.empty((len(self), 3), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.location
            self._cache_locations = values
        return values

    @locations.setter
    def locations(self, values): # array of V3
        self._cache_locations = np.array(to_array(values, (len(self), 3), '3-vector or array of 3-vectors'))
        for obj, v in zip(self._array, self._cache_locations):
            obj.location = v

    @property
    def lock_scales(self): # array of bool
        values = self._cache_lock_scales
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.lock_scale
            self._cache_lock_scales = values
        return values

    @lock_scales.setter
    def lock_scales(self, values): # array of bool
        self._cache_lock_scales = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_lock_scales):
            obj.lock_scale = v

    @property
    def pass_indices(self): # array of int
        values = self._cache_pass_indices
        if values is None:
            values = np.empty(len(self), np.int)
            for i, obj in enumerate(self._array):
                values[i] = obj.pass_index
            self._cache_pass_indices = values
        return values

    @pass_indices.setter
    def pass_indices(self, values): # array of int
        self._cache_pass_indices = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_pass_indices):
            obj.pass_index = v

    @property
    def rotation_eulers(self): # array of V3
        values = self._cache_rotation_eulers
        if values is None:
            values = np.empty((len(self), 3), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.rotation_euler
            self._cache_rotation_eulers = values
        return values

    @rotation_eulers.setter
    def rotation_eulers(self, values): # array of V3
        self._cache_rotation_eulers = np.array(to_array(values, (len(self), 3), '3-vector or array of 3-vectors'))
        for obj, v in zip(self._array, self._cache_rotation_eulers):
            obj.rotation_euler = v

    @property
    def rotation_modes(self): # array of str
        values = self._cache_rotation_modes
        if values is None:
            values = np.empty(len(self), np.object)
            for i, obj in enumerate(self._array):
                values[i] = obj.rotation_mode
            self._cache_rotation_modes = values
        return values

    @rotation_modes.setter
    def rotation_modes(self, values): # array of str
        self._cache_rotation_modes = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_rotation_modes):
            obj.rotation_mode = v

    @property
    def rotation_quaternions(self): # array of V4
        values = self._cache_rotation_quaternions
        if values is None:
            values = np.empty((len(self), 4), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.rotation_quaternion
            self._cache_rotation_quaternions = values
        return values

    @rotation_quaternions.setter
    def rotation_quaternions(self, values): # array of V4
        self._cache_rotation_quaternions = np.array(to_array(values, (len(self), 4), '4-vector or array of 4-vectors'))
        for obj, v in zip(self._array, self._cache_rotation_quaternions):
            obj.rotation_quaternion = v

    @property
    def scales(self): # array of V3
        values = self._cache_scales
        if values is None:
            values = np.empty((len(self), 3), np.float)
            for i, obj in enumerate(self._array):
                values[i] = obj.scale
            self._cache_scales = values
        return values

    @scales.setter
    def scales(self, values): # array of V3
        self._cache_scales = np.array(to_array(values, (len(self), 3), '3-vector or array of 3-vectors'))
        for obj, v in zip(self._array, self._cache_scales):
            obj.scale = v

    @property
    def show_all_edges_s(self): # array of bool
        values = self._cache_show_all_edges_s
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.show_all_edges
            self._cache_show_all_edges_s = values
        return values

    @show_all_edges_s.setter
    def show_all_edges_s(self, values): # array of bool
        self._cache_show_all_edges_s = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_show_all_edges_s):
            obj.show_all_edges = v

    @property
    def show_axis_s(self): # array of bool
        values = self._cache_show_axis_s
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.show_axis
            self._cache_show_axis_s = values
        return values

    @show_axis_s.setter
    def show_axis_s(self, values): # array of bool
        self._cache_show_axis_s = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_show_axis_s):
            obj.show_axis = v

    @property
    def show_bounds_s(self): # array of bool
        values = self._cache_show_bounds_s
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.show_bounds
            self._cache_show_bounds_s = values
        return values

    @show_bounds_s.setter
    def show_bounds_s(self, values): # array of bool
        self._cache_show_bounds_s = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_show_bounds_s):
            obj.show_bounds = v

    @property
    def show_empty_image_only_axis_aligneds(self): # array of bool
        values = self._cache_show_empty_image_only_axis_aligneds
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.show_empty_image_only_axis_aligned
            self._cache_show_empty_image_only_axis_aligneds = values
        return values

    @show_empty_image_only_axis_aligneds.setter
    def show_empty_image_only_axis_aligneds(self, values): # array of bool
        self._cache_show_empty_image_only_axis_aligneds = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_show_empty_image_only_axis_aligneds):
            obj.show_empty_image_only_axis_aligned = v

    @property
    def show_empty_image_orthographics(self): # array of bool
        values = self._cache_show_empty_image_orthographics
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.show_empty_image_orthographic
            self._cache_show_empty_image_orthographics = values
        return values

    @show_empty_image_orthographics.setter
    def show_empty_image_orthographics(self, values): # array of bool
        self._cache_show_empty_image_orthographics = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_show_empty_image_orthographics):
            obj.show_empty_image_orthographic = v

    @property
    def show_empty_image_perspectives(self): # array of bool
        values = self._cache_show_empty_image_perspectives
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.show_empty_image_perspective
            self._cache_show_empty_image_perspectives = values
        return values

    @show_empty_image_perspectives.setter
    def show_empty_image_perspectives(self, values): # array of bool
        self._cache_show_empty_image_perspectives = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_show_empty_image_perspectives):
            obj.show_empty_image_perspective = v

    @property
    def show_in_fronts(self): # array of bool
        values = self._cache_show_in_fronts
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.show_in_front
            self._cache_show_in_fronts = values
        return values

    @show_in_fronts.setter
    def show_in_fronts(self, values): # array of bool
        self._cache_show_in_fronts = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_show_in_fronts):
            obj.show_in_front = v

    @property
    def show_instancer_for_renders(self): # array of bool
        values = self._cache_show_instancer_for_renders
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.show_instancer_for_render
            self._cache_show_instancer_for_renders = values
        return values

    @show_instancer_for_renders.setter
    def show_instancer_for_renders(self, values): # array of bool
        self._cache_show_instancer_for_renders = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_show_instancer_for_renders):
            obj.show_instancer_for_render = v

    @property
    def show_instancer_for_viewports(self): # array of bool
        values = self._cache_show_instancer_for_viewports
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.show_instancer_for_viewport
            self._cache_show_instancer_for_viewports = values
        return values

    @show_instancer_for_viewports.setter
    def show_instancer_for_viewports(self, values): # array of bool
        self._cache_show_instancer_for_viewports = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_show_instancer_for_viewports):
            obj.show_instancer_for_viewport = v

    @property
    def show_names(self): # array of bool
        values = self._cache_show_names
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.show_name
            self._cache_show_names = values
        return values

    @show_names.setter
    def show_names(self, values): # array of bool
        self._cache_show_names = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_show_names):
            obj.show_name = v

    @property
    def show_only_shape_keys(self): # array of bool
        values = self._cache_show_only_shape_keys
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.show_only_shape_key
            self._cache_show_only_shape_keys = values
        return values

    @show_only_shape_keys.setter
    def show_only_shape_keys(self, values): # array of bool
        self._cache_show_only_shape_keys = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_show_only_shape_keys):
            obj.show_only_shape_key = v

    @property
    def show_texture_spaces(self): # array of bool
        values = self._cache_show_texture_spaces
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.show_texture_space
            self._cache_show_texture_spaces = values
        return values

    @show_texture_spaces.setter
    def show_texture_spaces(self, values): # array of bool
        self._cache_show_texture_spaces = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_show_texture_spaces):
            obj.show_texture_space = v

    @property
    def show_transparents(self): # array of bool
        values = self._cache_show_transparents
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.show_transparent
            self._cache_show_transparents = values
        return values

    @show_transparents.setter
    def show_transparents(self, values): # array of bool
        self._cache_show_transparents = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_show_transparents):
            obj.show_transparent = v

    @property
    def show_wires(self): # array of bool
        values = self._cache_show_wires
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.show_wire
            self._cache_show_wires = values
        return values

    @show_wires.setter
    def show_wires(self, values): # array of bool
        self._cache_show_wires = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_show_wires):
            obj.show_wire = v

    @property
    def track_axis_s(self): # array of str
        values = self._cache_track_axis_s
        if values is None:
            values = np.empty(len(self), np.object)
            for i, obj in enumerate(self._array):
                values[i] = obj.track_axis
            self._cache_track_axis_s = values
        return values

    @track_axis_s.setter
    def track_axis_s(self, values): # array of str
        self._cache_track_axis_s = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_track_axis_s):
            obj.track_axis = v

    @property
    def types(self): # array of str
        values = self._cache_types
        if values is None:
            values = np.empty(len(self), np.object)
            for i, obj in enumerate(self._array):
                values[i] = obj.type
            self._cache_types = values
        return values

    @types.setter
    def types(self, values): # array of str
        self._cache_types = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_types):
            obj.type = v

    @property
    def up_axis_s(self): # array of str
        values = self._cache_up_axis_s
        if values is None:
            values = np.empty(len(self), np.object)
            for i, obj in enumerate(self._array):
                values[i] = obj.up_axis
            self._cache_up_axis_s = values
        return values

    @up_axis_s.setter
    def up_axis_s(self, values): # array of str
        self._cache_up_axis_s = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_up_axis_s):
            obj.up_axis = v

    @property
    def use_empty_image_alphas(self): # array of bool
        values = self._cache_use_empty_image_alphas
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.use_empty_image_alpha
            self._cache_use_empty_image_alphas = values
        return values

    @use_empty_image_alphas.setter
    def use_empty_image_alphas(self, values): # array of bool
        self._cache_use_empty_image_alphas = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_use_empty_image_alphas):
            obj.use_empty_image_alpha = v

    @property
    def use_instance_faces_scales(self): # array of bool
        values = self._cache_use_instance_faces_scales
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.use_instance_faces_scale
            self._cache_use_instance_faces_scales = values
        return values

    @use_instance_faces_scales.setter
    def use_instance_faces_scales(self, values): # array of bool
        self._cache_use_instance_faces_scales = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_use_instance_faces_scales):
            obj.use_instance_faces_scale = v

    @property
    def use_instance_vertices_rotations(self): # array of bool
        values = self._cache_use_instance_vertices_rotations
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.use_instance_vertices_rotation
            self._cache_use_instance_vertices_rotations = values
        return values

    @use_instance_vertices_rotations.setter
    def use_instance_vertices_rotations(self, values): # array of bool
        self._cache_use_instance_vertices_rotations = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_use_instance_vertices_rotations):
            obj.use_instance_vertices_rotation = v

    @property
    def use_shape_key_edit_modes(self): # array of bool
        values = self._cache_use_shape_key_edit_modes
        if values is None:
            values = np.empty(len(self), np.bool)
            for i, obj in enumerate(self._array):
                values[i] = obj.use_shape_key_edit_mode
            self._cache_use_shape_key_edit_modes = values
        return values

    @use_shape_key_edit_modes.setter
    def use_shape_key_edit_modes(self, values): # array of bool
        self._cache_use_shape_key_edit_modes = np.array(to_array(values, (len(self), 1), '1-vector or array of 1-vectors'))
        for obj, v in zip(self._array, self._cache_use_shape_key_edit_modes):
            obj.use_shape_key_edit_mode = v


